## 缓存
 不言而喻，缓存是性能优化中最为简单高效的方式。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延时，缓存文件的重复利用，还可以减少宽带，降低网络负荷。以下内容简单说说缓存位置，缓存策略和应用场景。
### Service Worker
Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用Service Worker的前提是传输协议必须是https，因为Service Worker涉及拦截，需要https来保障安全。与浏览器内建的缓存机制不同，他可以自由控制缓存哪些文件，如何读取缓存，并且缓存是可持续性的。<br>

Service Worker 实现缓存一般分为三个步骤，首先注册Service Worker，监听install事件，缓存需要的文件。那么下次用户再次发送请求的时候就可以拦截的方式查询是否存在缓存，存在的话直接读取缓存，否则去服务端请求数据。如果没有在Service Worker中获取到缓存，不管后面是从哪里获取的数据，都是显示从Service Worker中获取的数据。

### Memory Cache
Memory Cache也就是内存中的缓存，主要包含当前页面中已经抓取到的资源，比如说样式，脚本，图片等。读取内存中的数据要比磁盘中快，可是持续的时间也很短，会随着进程的释放而释放。然后内存的容量有限，操作系统要精打细算内存的使用。

内存中有一块很重要的资源是preloader相关指令下载的资源（例如：<link rel="preloader">），作为页面常见优化手段之一，他可以促使浏览器一边渲染css，一边网络请求资源。内存缓存并不会关心返回资源的http缓存头Cache-Control是什么值，匹配的资源也不仅仅是URL，还可能对Content-Type，CORS等其他特征做校验。

### Disk Cache
Disk Cache 也就是存储在硬盘中的缓存，读取速度逊色一点，胜在容量和存储实效性上。

在所有的浏览器缓存中，Disk Cache的缓存面是最广的，他根据HTTP的请求字段判断哪些资源需要缓存，哪些资源不用请求直接使用，哪些资源已经过期需要重新请求，并且在跨站点的情况下，资源一旦没硬盘缓存下来就不再会请求数据。

那么浏览器会把哪些文件丢进内存中，哪些丢进磁盘中呢？<br>对于大文件而言，大概览是放在磁盘中，反之内存优先。当前系统内存使用率高的话，文件优先存进硬盘。

### Push Cache

当以上三种缓存都没命中的时候才会考虑，只存在会话中，持续时间短暂。

## 缓存策略

通常浏览器缓存策略分为两种，强缓存和对比（协商）缓存，缓存策略都是通过设置HTTP Header来实现。

大致流程：

```js
  第一次请求
  if (缓存结果||缓存标识){
      return '缓存数据'
  } else {
      请求服务器 => 返回请求数据和缓存规则 => 存入浏览器中
  }
```
### 强缓存
强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control
[详见](https://www.jianshu.com/p/54cc04190252)

Expires: max-age + 请求时间 <br>
Cache-Control: max-age/public/private/no-cache/max-stale等 <br>
Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires

### 协商缓存
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：
协商缓存生效，返回304和Not Modified，这个时候服务器告诉浏览器，资源没变，你可以使用缓存<br>
协商缓存失效，返回200和请求结果，这个时候，服务器告诉浏览器，资源变了，我直接返回给你，你并且需要把结果和缓存标识存在浏览器缓存中

协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。
- 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
- 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源

既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和If-None-Match。
浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了

